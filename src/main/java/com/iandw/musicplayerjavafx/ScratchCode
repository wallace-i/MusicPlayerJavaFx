/**
 *      Author: Ian Wallace copyright 2022 all rights reserved.
 *      Application: MusicPlayer
 *      Class:
 *      Notes:
 */
//        try() {
            // Load track metadata
//            metadataHashMap = MetadataFileIO.initializeMetadataFile(rootMusicDirectoryString, artistNameListView);

//        } catch (FileNotFoundException e) {
//            System.err.println("Metadata File not found");
//        }

****************************************************************************************************

    private void filePath() {
        String trackFileName = trackTableView.getSelectionModel().getSelectedItem().getTrackFileNameStr();
        trackTitleString = trackTableView.getSelectionModel().getSelectedItem().getTrackTitleStr();
        String albumDirectoryString = trackTableView.getSelectionModel().getSelectedItem().getAlbumDirectoryStr();
        albumTitleString = trackTableView.getSelectionModel().getSelectedItem().getAlbumTitleStr();
        currentPath = rootMusicDirectoryString + File.separator + artistNameString + File.separator + albumDirectoryString +
                File.separator + trackFileName;
    }

****************************************************************************************************

// read to temp file
// Json file for reading metadata directly from file instead of parsing through
    // Media objects in ArtistLibrary
    // [
    //      {"artistName": {"trackTitle": "trackFileName/trackContainerType/trackTitle/albumDirectory/trackAlbum/trackGenre/totalDuration"}}
    // ]
        JSONArray artistObjectList = new JSONArray();
        System.out.println(trackArray.isEmpty());
        System.out.println("writing to MetadataHashMap.json");
        for (Track track : trackArray) {
            JSONObject metaDataObject = new JSONObject();
            String metaDataString = track.getTrackFileNameStr() + separator + track.getTrackContainerTypeStr() +
                    separator + track.getTrackTitleStr() + separator + track.getAlbumDirectoryStr() + separator +
                    track.getAlbumTitleStr() + separator + track.getTrackGenreStr() + separator + track.getTrackDurationStr();

            metaDataObject.put(track.getTrackTitleStr(), metaDataString);
            System.out.printf("Metadata String: %s", metaDataObject);

            JSONObject artistObject = new JSONObject();
            artistObject.put(artistNameString, metaDataObject);
            System.out.printf("Artist Object: %s", artistObject);

            artistObjectList.add(artistObject);
            System.out.printf("ArtistObjectList: %s", artistObjectList);

        }

        try (FileWriter file = new FileWriter(ResourceURLs.getMetadataHashMapURL())) {
            file.write(artistObjectList.toJSONString());
            file.flush();

        } catch (IOException e) {
            e.printStackTrace();
        }



    }

****************************************************************************************************

                                    // Use wrapper to output metadata collected inside listener to list array
                                    // for use in serializing the data to a file.
    //                                var wrapper = new Object() {  String artistName;
    //                                                              String trackFileName;
    //                                                              String trackContainerType;
    //                                                              String trackTitle;
    //                                                              String albumDirectory;
    //                                                              String trackAlbum;
    //                                                              String trackGenre;
    //                                                              Duration duration;
    //                                };


                                            // Load wrapper with metadata
    //                                        wrapper.artistName = artistName;
    //                                        wrapper.trackFileName = trackFileName;
    //                                        wrapper.trackContainerType = trackContainerType;
    //                                        wrapper.trackTitle = trackTitle;
    //                                        wrapper.albumDirectory = albumDirectory;
    //                                        wrapper.trackAlbum = trackAlbum;
    //                                        wrapper.trackGenre = trackGenre;
    //                                        wrapper.duration = mediaPlayer.getTotalDuration();

                                    // Add track data to ArrayList
                                    //System.out.printf("wrapperartist:%s%n", wrapper.artistName);
    //                                Track tempTrack = new Track(
    //                                        wrapper.artistName,
    //                                        wrapper.trackFileName,
    //                                        wrapper.trackContainerType,
    //                                        wrapper.trackTitle,
    //                                        wrapper.albumDirectory,
    //                                        wrapper.trackAlbum,
    //                                        wrapper.trackGenre,
    //                                        wrapper.duration
    //                                );

    //                                trackArrayList.add(tempTrack);



****************************************************************************************************






                // Check map for key, populate trackTableView with value if true
//                if (metadataHashMap.containsKey(artistNameString)) {
//                    System.out.println("Reading from MetadataHashMap.ser");
//                    trackList = metadataHashMap.getTrackList(artistNameString);
//                    trackTableView.setItems(trackList);
//                    tableSize = metadataHashMap.getNumberOfTracks();
//
//                } else {
                    // Populate directly from artist directory, then write to map
//                    System.out.println("Reading from directory");




                        // write metadata to file
    //                    Metadata artistMetadata = new Metadata(trackList, artistNameString);
    //                    MetadataFileIO.metadataHashMapOutput(artistMetadata.getMetadata());





    //                }

****************************************************************************************************

    private void searchTree(String searchText) throws IOException {
            System.out.println("searching...");
            String result = searchTreeMap.searchForKey(searchText.toLowerCase());

            if (result == null) {
                searchField.setText("Not Found.");

            } else  {
                searching = true;
                artistNameValue = result.substring(0, result.indexOf(File.separator));
                String trackIndexValueStr = result.substring(result.indexOf(File.separator) + 1);
                trackIndexValue = Integer.parseInt(trackIndexValueStr);

                if (playing) {
                    stopMedia(true);
                }

                // if not searching for artist, select the corresponding track in tableview
                if (!trackIndexValueStr.equals("null")) {
                    //TODO => Exception in thread "JavaFX Application Thread" java.lang.IndexOutOfBoundsException: Index 7 out of bounds for length 0
                    listViewSelected();
                    tableViewSelected();

                } else {
                    listViewSelected();
                }
            }

        }


****************************************************************************************************


            private void searchFilePath() {
                artistNameString = artistNameValue;
                String trackFileName = trackTableView.getItems().get(trackIndexValue).getTrackFileNameStr();
                System.out.println(trackFileName);
                trackTitleString = trackTableView.getItems().get(trackIndexValue).getTrackTitleStr();
                String albumDirectoryString = trackTableView.getItems().get(trackIndexValue).getAlbumDirectoryStr();
                albumTitleString = trackTableView.getItems().get(trackIndexValue).getAlbumTitleStr();
                currentPath = rootMusicDirectoryString + File.separator + artistNameString + File.separator + albumDirectoryString +
                        File.separator + trackFileName;

            }





                @FXML
                private void handleSearchEnterPressed() {
            //        searchField.setOnKeyPressed( event -> {
            //            if (event.getCode() == KeyCode.ENTER) {
            //                try {
            //                    searchTree(searchField.getText());
            //                } catch (IOException e) {
            //                    throw new RuntimeException(e);
            //                }
            //            }
            //        });
                }


****************************************************************************************************

package com.iandw.musicplayerjavafx;

import java.io.*;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;
import java.util.TreeMap;


public class SearchTreeMap {
    // searchMap => Treemap (K: String, V: String)
    // Key: Artist Name || Album Title || Track Title
    // Value: Path  =>  artist name path => "artistName"
    //                  album title path => "artistName"
    //                  track title path => "artistName" + File.separator + trackFilename
    private final TreeMap<String, String> searchMap;

    public SearchTreeMap(String musicRootDirectory) throws IOException {
        searchMap = new TreeMap<>();
        fileInput();

        if (searchMap.isEmpty()) {
            System.out.println("Initializing search tree");
            initializeSearchTree(musicRootDirectory);
            //fileOutput();
        } else {
            System.out.println("SearchTreeMap input from file");
            //fileInput();
        }

    }

    public String searchForKey(String key) {
        String searchResult = null;

        if (searchMap.containsKey(key)) {
            searchResult = searchMap.get(key);
        }

        return searchResult;
    }

    public TreeMap<String, String> getSearchMap() { return searchMap; }

    public void setSearchMap(String key, String value) { searchMap.put(key, value); }

    private void fileInput() throws IOException {
        Properties properties = new Properties();
        properties.load(new FileInputStream(ResourceURLs.getSearchTreeMapURL()));

        for (String key : properties.stringPropertyNames()) {
            searchMap.put(key, properties.get(key).toString());
        }
    }

    private void fileOutput() throws IOException {
        Properties properties = new Properties();

        properties.putAll(searchMap);

        properties.store(new FileOutputStream(ResourceURLs.getSearchTreeMapURL()), null);

        // Debugger
//        for (String key : searchMap.keySet()) {
//            System.out.printf("K:%s V:%s%n", key, searchMap.get(key));
//        }

    }

    private void initializeSearchTree(String musicRootDirectory) throws IOException {
        Path rootPath = Paths.get(musicRootDirectory);

        if (Files.exists(rootPath)) {
            if (Files.isDirectory(rootPath)) {

                DirectoryStream<Path> musicLibraryDirectory = Files.newDirectoryStream(rootPath);

                for (Path artistDir : musicLibraryDirectory) {
                    if (Files.isDirectory(artistDir)) {
                        String artistNameStr = artistDir.toString();
                        artistNameStr = artistNameStr.substring(artistNameStr.lastIndexOf(File.separator) + 1);

                        // Load artistName into search tree
                        searchMap.put(artistNameStr.toLowerCase(), artistNameStr + File.separator + "null");

                        DirectoryStream<Path> artistDirectory = Files.newDirectoryStream(artistDir);
                        int trackIndex = 0;

                        for (Path albumDir : artistDirectory) {
                            if (Files.isDirectory(albumDir)) {

                                String albumTitleStr = albumDir.toString();
                                albumTitleStr = albumTitleStr.substring(albumTitleStr.lastIndexOf(File.separator) + 1);;

                                // Load Album Title into search tree
                                searchMap.put(albumTitleStr.toLowerCase(), artistNameStr + File.separator + trackIndex);

                                DirectoryStream<Path> albumDirectory = Files.newDirectoryStream(albumDir);
                                for (Path track : albumDirectory) {
                                    String trackTitleStr = track.toString();
                                    trackTitleStr = trackTitleStr.substring(trackTitleStr.lastIndexOf(File.separator) + 1, trackTitleStr.lastIndexOf('.'));

                                    if (Character.isDigit(trackTitleStr.charAt(0))) {
                                        if (trackTitleStr.contains(" - ")) {
                                            trackTitleStr = trackTitleStr.substring(trackTitleStr.lastIndexOf(' ') + 1);
                                        } else {
                                            trackTitleStr = trackTitleStr.substring(trackTitleStr.indexOf(' ') + 1);
                                        }
                                    }

                                    // Load TrackTitle into search tree
                                    searchMap.put(trackTitleStr.toLowerCase(), artistNameStr + File.separator + trackIndex);
                                    trackIndex++;
                                }
                            }
                        }
                    }
                }
            }

        } else {
            System.out.printf("%s does not exist%n", rootPath);
        }

    }

}



****************************************************************************************************



package com.iandw.musicplayerjavafx;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.ListView;
import javafx.scene.control.TableView;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;

public class Metadata extends HashMap {
    //      HashMap<ArtistName, HashMap<TrackTitle, Track Object>>
    private final HashMap<String, HashMap<String, Track>> metadataHashMap;
    private int numberOfTracks;

    public Metadata() {
        metadataHashMap = new HashMap<>();

    }

    //TODO => Initiailze function
    // have metadata re-initialize when directory changes in settings so only .ser file
    // is enough for app.

    // Setter
    public void setTrackMetadata(Track track, String artistName) {

        //metadataHashMap.get(artistName).put(track.getTrackTitleStr(), track);
    }

    public void setMetadata(String rootMusicDirectoryString, ListView<String> artistNameListView) throws IOException {

        HashMap<String, Track> artistTracksMap = new HashMap<>();

        // Loop through artists
//        for (String artistName : artistNameListView.getItems()) {
//            String currentPath = rootMusicDirectoryString + File.separator + artistName;
//            ArtistLibrary artistLibrary = new ArtistLibrary(currentPath);
//
//            //TODO => empty tracklist bug, hashmap not populating
////            System.out.printf("trackListisEmpty():%s%n", trackList.;
//
//            // Loop through tracks per artist
//            for (Track track : ) {
//                // Populate artistTracksMap with file name and track object for each
//                // track in artist directory
//                artistTracksMap.put(track.getTrackFileNameStr(), track);
//                System.out.printf("metadataputtracktitle:%s%n:", track.getTrackTitleStr());
//            }
//
//            // key => artistName, value => artistTracksMap
//            metadataHashMap.put(artistName, artistTracksMap);
//
//        }

    }

    // Getter
    public HashMap<String, HashMap<String, Track>> getHashMap() {
        return metadataHashMap;
    }

    public ObservableList<Track> getTrackList(String artistNameString) {
        ObservableList<Track> trackList = FXCollections.observableArrayList();

        trackList.addAll(metadataHashMap.get(artistNameString).values());
        numberOfTracks = trackList.size();
        System.out.printf("currentartisttracksamount: %s%n", numberOfTracks);

        return trackList;
    };

    public int getNumberOfTracks() {
        return numberOfTracks;
    }
}



****************************************************************************************************


package com.iandw.musicplayerjavafx;

import javafx.scene.control.ListView;

import java.io.*;
import java.util.HashMap;
import java.util.Objects;


public class MetadataFileIO {

    private static void metadataHashMapOutput(Metadata artistMetadata) throws FileNotFoundException {

        try {
            FileOutputStream fileOut = new FileOutputStream(ResourceURLs.getMetadataHashMapURL());
            ObjectOutputStream objOut = new ObjectOutputStream(fileOut);

            for (HashMap<String, Track> trackTitles : artistMetadata.getHashMap().values()) {

                for (Track track : trackTitles.values()) {
                    objOut.writeObject(track);
                }
            }

            objOut.close();
            fileOut.close();
            System.out.printf("Serialized data saved at %s", ResourceURLs.getMetadataHashMapURL());


        } catch (IOException e) {
            throw new RuntimeException(e);
        }


    }

    private static Metadata metadataHashMapInput(Metadata metadataHashMap) {
        HashMap<String, Track> trackHashMap = new HashMap<>();
        Track tempTrack;
        String currentArtist;
        String previousTrackArtist;
        String trackTitle;

        try {
            FileInputStream fileIn = new FileInputStream(ResourceURLs.getMetadataHashMapURL());
            ObjectInputStream inObj = new ObjectInputStream(fileIn);

            // Initialize map, load first track
            tempTrack = (Track) inObj.readObject();
            currentArtist = tempTrack.getArtistNameStr();
            trackTitle = tempTrack.getTrackTitleStr();
            trackHashMap.put(trackTitle, tempTrack);
            metadataHashMap.put(currentArtist, trackHashMap);


            // Load rest of file
            while (fileIn.available() > 0) {

                // Load all tracks of the same artist into trackHashMap
                do {
                    previousTrackArtist = currentArtist;
                    tempTrack = (Track) inObj.readObject();
                    currentArtist = tempTrack.getArtistNameStr();
                    trackTitle = tempTrack.getTrackTitleStr();
                    trackHashMap.put(trackTitle, tempTrack);

                } while (Objects.equals(previousTrackArtist, currentArtist));

                // Load trackHashMap into Artist metadataHashMap
                metadataHashMap.put(currentArtist, trackHashMap);

                // reset map
                trackHashMap.clear();
            }

            inObj.close();
            fileIn.close();

        } catch (IOException i) {
            i.printStackTrace();
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }

        return metadataHashMap;
    }

    public static Metadata initializeMetadataFile(String rootMusicDirectoryString, ListView<String> artistNameListView) throws IOException {
        System.out.println("Initializing metadata file");
        Metadata metadataHashMap = new Metadata();
        // gather each track file metadata and copy to Metadata object
        metadataHashMap.setMetadata(rootMusicDirectoryString, artistNameListView);

        // write metadataHashMap to file
        metadataHashMapOutput(metadataHashMap);

        return metadataHashMap;
    }

    public static Metadata inputMetadataFromFile() {
        Metadata metadataHashMap = new Metadata();

        return metadataHashMapInput(metadataHashMap);
    }

}

****************************************************************************************************


